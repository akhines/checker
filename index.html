<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>MD Homeowner Verification</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js">
// ---------------------------------------------------------------------------
// DEBUG ‚Äî shows raw SDAT API response + match logic for first 5 rows
// ---------------------------------------------------------------------------
document.getElementById("btnDebug").addEventListener("click", async () => {
  if (!csvData) { alert("Load a CSV first."); return; }

  const decFirstCol = document.getElementById("colDecFirst").value;
  const decLastCol  = document.getElementById("colDecLast").value;
  if (!decFirstCol || !decLastCol) { alert("Select First Name and Last Name columns first."); return; }

  const panel = document.getElementById("debugPanel");
  panel.classList.remove("hidden");
  panel.textContent = "Running debug on first 5 rows...\n\n";

  const sample = csvData.rows.slice(0, 5);

  for (let i = 0; i < sample.length; i++) {
    const row      = sample[i];
    const decFirst = (row[decFirstCol]||"").trim();
    const decLast  = (row[decLastCol] ||"").trim();
    const cleaned  = cleanLastName(decLast);

    panel.textContent += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n";
    panel.textContent += `ROW ${i+1}: First="${decFirst}"  Last="${decLast}"\n`;
    panel.textContent += `Searching SDAT for last name: "${cleaned}"\n`;

    if (!cleaned || cleaned.length < 2) {
      panel.textContent += "‚ö† Last name too short or empty after cleaning ‚Äî skipped\n\n";
      continue;
    }

    const where = `upper(ownname1) like '%${cleaned}%' OR upper(ownname2) like '%${cleaned}%'`;
    const url   = ENDPOINT + "?$limit=20&$where=" + encodeURIComponent(where);
    panel.textContent += `URL: ${url}\n\n`;

    try {
      const r = await fetch(url);
      const d = await r.json();

      if (!d.length) {
        panel.textContent += `SDAT RESPONSE: 0 records returned\n`;
        panel.textContent += `‚Üí Result: NO MATCH (no records for "${cleaned}")\n\n`;
        continue;
      }

      panel.textContent += `SDAT RESPONSE: ${d.length} record(s) returned\n\n`;

      d.forEach((rec, idx) => {
        const o1 = (rec.ownname1||"").trim();
        const o2 = (rec.ownname2||"").trim();
        const addr = [rec.premsnum,rec.premsnam,rec.premcity,rec.premzip].filter(Boolean).join(" ");

        panel.textContent += `  Record ${idx+1}:\n`;
        panel.textContent += `    ownname1: "${o1}"\n`;
        panel.textContent += `    ownname2: "${o2}"\n`;
        panel.textContent += `    address:  "${addr}"\n`;

        for (const candidate of [o1,o2].filter(Boolean)) {
          const {status,reason} = classifyMatch(decFirst, decLast, candidate);
          const icon = status==="confirmed"?"‚úÖ":status==="possible"?"‚ö†Ô∏è":"‚ùå";
          panel.textContent += `    ${icon} vs "${candidate}": ${status.toUpperCase()} ‚Äî ${reason}\n`;
        }
        panel.textContent += "\n";
      });

    } catch(e) {
      panel.textContent += `ERROR fetching SDAT: ${e.message}\n\n`;
    }

    await new Promise(r => setTimeout(r, 300));
  }

  panel.textContent += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nDebug complete. Copy this output and share it.\n";
  panel.scrollTop = panel.scrollHeight;
});

</script>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  body { background: #0d1117; color: #e6edf3; font-family: Georgia, serif; min-height: 100vh; padding: 2rem 1rem; }
  .wrap { max-width: 720px; margin: 0 auto; }
  .eyebrow { display: flex; align-items: center; gap: 8px; font-family: monospace; font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.12em; color: #3fb950; margin-bottom: 0.5rem; }
  .dot { width: 8px; height: 8px; border-radius: 50%; background: #238636; flex-shrink: 0; }
  h1 { font-size: 1.9rem; font-weight: 700; color: #fff; margin-bottom: 0.25rem; }
  .subtitle { color: #8b949e; font-size: 0.9rem; font-style: italic; margin-bottom: 2rem; }
  .card { background: #161b22; border: 1px solid #30363d; border-radius: 8px; padding: 1.5rem; margin-bottom: 1.25rem; }
  .card-success { background: #161b22; border: 1px solid #238636; border-radius: 8px; padding: 1.5rem; margin-bottom: 1.25rem; }
  .card-title { font-family: monospace; font-size: 0.85rem; color: #58a6ff; border-bottom: 1px solid #21262d; padding-bottom: 0.6rem; margin-bottom: 1.25rem; }
  .card-title-green { font-family: monospace; font-size: 0.85rem; color: #3fb950; border-bottom: 1px solid #21262d; padding-bottom: 0.6rem; margin-bottom: 1.25rem; }
  .dropzone { border: 2px dashed #30363d; border-radius: 8px; padding: 2.5rem; text-align: center; cursor: pointer; transition: border-color 0.2s, background 0.2s; }
  .dropzone:hover, .dropzone.active { border-color: #58a6ff; background: rgba(88,166,255,0.04); }
  .badge { display: inline-block; background: #1a3d22; color: #3fb950; border-radius: 20px; padding: 0.2rem 0.75rem; font-family: monospace; font-size: 0.75rem; font-weight: 600; margin-top: 0.4rem; }
  .field { margin-bottom: 1rem; }
  .field label { display: block; font-family: monospace; font-size: 0.69rem; text-transform: uppercase; letter-spacing: 0.1em; color: #8b949e; margin-bottom: 0.3rem; }
  .field .hint { font-family: monospace; font-size: 0.71rem; color: #6e7681; margin-top: 0.2rem; }
  select { width: 100%; background: #0d1117; border: 1px solid #30363d; color: #e6edf3; border-radius: 4px; padding: 0.45rem 0.7rem; font-size: 0.85rem; font-family: monospace; outline: none; }
  select:focus { border-color: #58a6ff; }
  .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; }
  .grid3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1rem; }
  .btn-run { background: #238636; color: #fff; border: none; border-radius: 6px; padding: 0.6rem 1.4rem; font-family: monospace; font-size: 0.85rem; font-weight: 700; cursor: pointer; transition: background 0.15s; }
  .btn-run:hover:not(:disabled) { background: #2ea043; }
  .btn-run:disabled { background: #1a3d22; color: #4d7a55; cursor: not-allowed; }
  .btn-stop { background: #da3633; color: #fff; border: none; border-radius: 6px; padding: 0.45rem 0.9rem; font-family: monospace; font-size: 0.78rem; cursor: pointer; }
  .btn-dl { background: #1f6feb; color: #fff; border: none; border-radius: 6px; padding: 0.6rem 1.4rem; font-family: monospace; font-size: 0.85rem; font-weight: 700; cursor: pointer; }
  .btn-dl:hover { background: #388bfd; }
  .btn-row { display: flex; align-items: center; gap: 0.75rem; flex-wrap: wrap; }
  .prog-wrap { margin-top: 0.75rem; background: #21262d; border-radius: 3px; height: 5px; overflow: hidden; }
  .prog-fill { height: 100%; background: linear-gradient(90deg, #238636, #2ea043); border-radius: 3px; transition: width 0.3s; }
  .prog-text { font-family: monospace; font-size: 0.78rem; color: #8b949e; }
  .log { background: #0d1117; border: 1px solid #21262d; border-radius: 4px; padding: 0.6rem 0.75rem; max-height: 150px; overflow-y: auto; font-family: monospace; font-size: 0.72rem; color: #8b949e; margin-top: 0.75rem; }
  .stats { display: grid; grid-template-columns: repeat(5, 1fr); gap: 0.6rem; margin-bottom: 1.25rem; }
  .stat-label { font-family: monospace; font-size: 0.6rem; text-transform: uppercase; letter-spacing: 0.06em; color: #8b949e; margin-bottom: 0.2rem; }
  .stat-value { font-size: 1.5rem; font-weight: 700; }
  .green  { color: #3fb950; }
  .yellow { color: #e3b341; }
  .orange { color: #f0883e; }
  .blue   { color: #58a6ff; }
  .code-tag { background: #21262d; color: #8b949e; border-radius: 3px; padding: 0.1rem 0.4rem; font-family: monospace; font-size: 0.72rem; }
  .info-box { background: #1c2128; border: 1px solid #30363d; border-radius: 4px; padding: 0.65rem 0.85rem; font-family: monospace; font-size: 0.75rem; color: #8b949e; margin-bottom: 1rem; line-height: 1.6; }
  .legend-box { background: #1c2128; border: 1px solid #30363d; border-radius: 4px; padding: 0.65rem 0.85rem; font-family: monospace; font-size: 0.73rem; color: #8b949e; margin-bottom: 1rem; line-height: 2; }
  .tab-legend { display: flex; gap: 0.75rem; margin-bottom: 1rem; flex-wrap: wrap; }
  .tab-pill { display: inline-flex; align-items: center; gap: 0.4rem; background: #21262d; border-radius: 4px; padding: 0.3rem 0.7rem; font-family: monospace; font-size: 0.73rem; }
  .tab-pill .swatch { width: 10px; height: 10px; border-radius: 2px; flex-shrink: 0; }
  .section-label { font-family: monospace; font-size: 0.72rem; text-transform: uppercase; letter-spacing: 0.1em; color: #58a6ff; margin-bottom: 0.6rem; margin-top: 0.25rem; }
  .divider { border: none; border-top: 1px solid #21262d; margin: 1rem 0; }
  .footer { text-align: center; font-family: monospace; font-size: 0.7rem; color: #4d7a55; margin-top: 2rem; }
  .hidden { display: none; }
  .preview-table { width: 100%; font-family: monospace; font-size: 0.7rem; border-collapse: collapse; margin-top: 0.5rem; }
  .preview-table th { background: #21262d; color: #8b949e; padding: 0.3rem 0.5rem; text-align: left; font-weight: normal; }
  .preview-table td { padding: 0.3rem 0.5rem; border-top: 1px solid #21262d; color: #58a6ff; }
</style>
</head>
<body>
<div class="wrap">

  <div class="eyebrow"><span class="dot"></span>Maryland SDAT ¬∑ Public Records</div>
  <h1>Homeowner Verification</h1>
  <p class="subtitle">Three-tier matching ‚Äî Confirmed ¬∑ Possible ¬∑ No Match</p>

  <!-- Step 1: Upload -->
  <div class="card">
    <div class="card-title">‚ë† Upload CSV</div>
    <div class="dropzone" id="dropzone">
      <input type="file" accept=".csv" id="fileInput" class="hidden"/>
      <div id="dropEmpty">
        <div style="font-size:2rem;margin-bottom:0.5rem">‚¨ÜÔ∏è</div>
        <div style="color:#8b949e;font-size:0.9rem">Drop your CSV here, or click to browse</div>
      </div>
      <div id="dropLoaded" class="hidden">
        <div style="font-family:monospace;margin-bottom:0.4rem" id="fileName"></div>
        <span class="badge" id="recordCount"></span>
      </div>
    </div>
  </div>

  <!-- Step 2: Column mapping -->
  <div class="card hidden" id="mappingCard">
    <div class="card-title">‚ë° Map Columns</div>
    <div class="info-box" id="detectedInfo"></div>

    <div class="section-label">Decedent Name</div>
    <div class="grid2">
      <div class="field">
        <label>First Name Column *</label>
        <select id="colDecFirst"></select>
        <div class="hint">e.g. "Decedent First Name" or split from full name</div>
      </div>
      <div class="field">
        <label>Last Name Column *</label>
        <select id="colDecLast"></select>
        <div class="hint">e.g. "Decedent Last Name"</div>
      </div>
    </div>

    <hr class="divider"/>
    <div class="section-label">Address (display only ‚Äî search is by name statewide)</div>
    <div class="grid2">
      <div class="field">
        <label>Address Column</label>
        <select id="colAddr"></select>
        <div class="hint">Shown in output, not used for SDAT search</div>
      </div>
      <div class="field">
        <label>County Column</label>
        <select id="colCounty"></select>
        <div class="hint">Shown in output</div>
      </div>
    </div>

    <hr class="divider"/>
    <div class="section-label">Preview ‚Äî first 3 rows</div>
    <div id="previewWrap" style="overflow-x:auto;"></div>
  </div>

  <!-- Step 3: Run -->
  <div class="card hidden" id="runCard">
    <div class="card-title">‚ë¢ Verify Against SDAT</div>
    <div class="legend-box">
      <span style="color:#3fb950">‚úÖ CONFIRMED</span> ‚Äî First &amp; last name both match SDAT owner (legal names only)<br/>
      <span style="color:#e3b341">‚ö†Ô∏è POSSIBLE</span> ‚Äî Last name matches, first is a nickname or initial ‚Äî needs human review<br/>
      <span style="color:#f0883e">‚ùå NO MATCH</span> ‚Äî No valid name match found in SDAT
    </div>
    <div class="btn-row">
      <button class="btn-run" id="btnRun">‚ñ∂&nbsp; Run Verification</button>
      <button class="btn-run" id="btnDebug" style="background:#6e40c9;margin-left:0">üîç&nbsp; Debug First 5</button>
      <button class="btn-stop hidden" id="btnStop">‚ñ†&nbsp; Stop</button>
      <span class="prog-text hidden" id="progText"></span>
    </div>
    <div class="prog-wrap hidden" id="progWrap">
      <div class="prog-fill" id="progFill" style="width:0%"></div>
    </div>
    <div id="debugPanel" class="hidden" style="margin-top:1rem;background:#0d1117;border:1px solid #6e40c9;border-radius:4px;padding:0.75rem;font-family:monospace;font-size:0.71rem;color:#c9d1d9;max-height:500px;overflow-y:auto;white-space:pre-wrap;line-height:1.6;"></div>
    <div class="log hidden" id="logBox"></div>
  </div>

  <!-- Results -->
  <div class="card-success hidden" id="resultsCard">
    <div class="card-title-green">‚úì Verification Complete</div>
    <div class="stats">
      <div><div class="stat-label">Checked</div><div class="stat-value blue"   id="statTotal">0</div></div>
      <div><div class="stat-label">Confirmed</div><div class="stat-value green"  id="statConfirmed">0</div></div>
      <div><div class="stat-label">Possible</div><div class="stat-value yellow" id="statPossible">0</div></div>
      <div><div class="stat-label">No Match</div><div class="stat-value orange" id="statNone">0</div></div>
      <div><div class="stat-label">Hit Rate</div><div class="stat-value"        id="statRate">0%</div></div>
    </div>
    <div class="tab-legend">
      <div class="tab-pill"><span class="swatch" style="background:#238636"></span>Tab 1: Confirmed</div>
      <div class="tab-pill"><span class="swatch" style="background:#b3891b"></span>Tab 2: Possible ‚Äî Review</div>
      <div class="tab-pill"><span class="swatch" style="background:#b03a2e"></span>Tab 3: No Match</div>
    </div>
    <button class="btn-dl" id="btnDownload">‚¨á&nbsp; Download Excel (.xlsx)</button>
    <div style="margin-top:0.75rem;font-family:monospace;font-size:0.72rem;color:#6e7681">
      All tabs include original columns +
      <span class="code-tag">_Match_Status</span>
      <span class="code-tag">_Match_Reason</span>
      <span class="code-tag">_SDAT_First</span>
      <span class="code-tag">_SDAT_Last</span>
      <span class="code-tag">_SDAT_Address</span>
    </div>
  </div>

  <div class="footer">Maryland Open Data ¬∑ SDAT Real Property (x8a5-h2sy) ¬∑ Searches statewide by legal name</div>
</div>

<script>
const ENDPOINT = "https://opendata.maryland.gov/resource/x8a5-h2sy.json";
let csvData = null;
let confirmedRows = [], possibleRows = [], noMatchRows = [];
let aborted = false;

// ---------------------------------------------------------------------------
// NICKNAME MAP
// ---------------------------------------------------------------------------
const NICKNAMES = {
  WILLIAM:["BILL","BILLY","WILL","WILLY","LIAM"],
  ROBERT:["BOB","BOBBY","ROB","ROBBIE"],
  JAMES:["JIM","JIMMY","JAMIE","JAY"],
  JOHN:["JACK","JOHNNY","JON"],
  MICHAEL:["MIKE","MIKEY","MICK","MICKEY"],
  RICHARD:["RICK","RICKY","DICK","RICH"],
  CHARLES:["CHUCK","CHARLIE","CHAS"],
  THOMAS:["TOM","TOMMY","THOM"],
  JOSEPH:["JOE","JOEY"],
  DAVID:["DAVE","DAVY"],
  EDWARD:["ED","EDDIE","NED","TED","TEDDY"],
  HENRY:["HANK","HAL"],
  HAROLD:["HAL","HARRY"],
  DONALD:["DON","DONNIE"],
  RONALD:["RON","RONNIE"],
  KENNETH:["KEN","KENNY"],
  STEVEN:["STEVE","STEVIE"],
  STEPHEN:["STEVE","STEVIE"],
  DANIEL:["DAN","DANNY"],
  ANTHONY:["TONY"],
  ANDREW:["ANDY","DREW"],
  FRANK:["FRANCIS","FRANKIE"],
  FRANCIS:["FRANK","FRAN"],
  PATRICK:["PAT","PATTY"],
  TIMOTHY:["TIM","TIMMY"],
  RAYMOND:["RAY"],
  LAWRENCE:["LARRY"],
  LARRY:["LAWRENCE"],
  WALTER:["WALT","WALLY"],
  PETER:["PETE"],
  EUGENE:["GENE"],
  ARTHUR:["ART","ARTIE"],
  ALBERT:["AL","BERT"],
  SAMUEL:["SAM","SAMMY"],
  FREDERICK:["FRED","FREDDY"],
  FRED:["FREDERICK","FREDDY"],
  GERALD:["JERRY","GERRY"],
  JERRY:["GERALD","GERRY"],
  LEONARD:["LEN","LENNY","LEO"],
  LOUIS:["LOU","LOUIE","LEWIS"],
  LEWIS:["LOU","LOUIE","LOUIS"],
  NATHANIEL:["NAT","NATE"],
  NICHOLAS:["NICK","NICKY"],
  NORMAN:["NORM"],
  RANDOLPH:["RANDY"],
  RANDY:["RANDOLPH"],
  RODNEY:["ROD"],
  RUSSELL:["RUSS"],
  STANLEY:["STAN"],
  THEODORE:["TED","TEDDY","THEO"],
  VICTOR:["VIC"],
  VINCENT:["VIN","VINCE","VINNY"],
  GEORGE:["GEORGIE"],
  HOWARD:["HOWIE"],
  DOUGLAS:["DOUG"],
  DENNIS:["DENNY"],
  CLIFFORD:["CLIFF"],
  JEROME:["JERRY"],
  HERMAN:["HERM"],
  ERNEST:["ERNIE"],
  EARL:["EARLE"],
  ELIZABETH:["LIZ","LIZZIE","BETH","BETTY","BETTE","ELIZA","ELLIE","LIBBY","LISA","ELISE","ELSIE"],
  BETTY:["ELIZABETH","BETTE"],
  MARGARET:["MAGGIE","MEG","PEGGY","PEG","MARGE","MARGO","RITA"],
  MARY:["MARIE","MOLLY","MAE","MAY","MAMIE","POLLY"],
  PATRICIA:["PAT","PATTY","PATTI","TRICIA","TRISH"],
  BARBARA:["BARB","BARBIE","BABS"],
  DOROTHY:["DOT","DOTTIE"],
  HELEN:["NELL","NELLIE"],
  VIRGINIA:["GINNY","GINGER"],
  CATHERINE:["CATHY","KATHY","KATE","KATIE","KAY"],
  KATHERINE:["KATHY","KATE","KATIE","KAY","CATHY"],
  KATHLEEN:["KATHY","KATE","KATIE","KAY"],
  CAROLYN:["CAROL","CARRIE","LYNN"],
  CAROL:["CAROLE","CAROLYN","CARRIE"],
  JUDITH:["JUDY"],
  JUDY:["JUDITH"],
  PAMELA:["PAM"],
  SANDRA:["SANDY","SANDI"],
  SUSAN:["SUE","SUSIE","SUZY"],
  TERESA:["TERRY","TERI","TESS"],
  THERESA:["TERRY","TERI","TESS"],
  DEBORAH:["DEB","DEBBIE"],
  DEBRA:["DEB","DEBBIE"],
  CYNTHIA:["CINDY"],
  CONSTANCE:["CONNIE"],
  CONNIE:["CONSTANCE"],
  BEVERLY:["BEV"],
  FRANCES:["FRAN","FRANNIE"],
  LILLIAN:["LILY","LIL"],
  MILDRED:["MILLIE"],
  ROSEMARY:["ROSIE","ROSE"],
  EVELYN:["EVE","EVIE"],
  JOSEPHINE:["JO","JOSIE"],
  JOANNE:["JO","JOAN"],
  ROBERTA:["BOBBIE"],
  VIVIAN:["VIV"],
  DOLORES:["DEE","LOLA"],
  LAURA:["LAURIE","LORI"],
  LORI:["LAURA","LAURIE"],
  LORRAINE:["LORI"],
  GERALDINE:["GERI","JERRY"],
};

const NICKNAME_REVERSE = {};
for (const [legal, nicks] of Object.entries(NICKNAMES)) {
  for (const nick of nicks) {
    if (!NICKNAME_REVERSE[nick]) NICKNAME_REVERSE[nick] = [];
    if (!NICKNAME_REVERSE[nick].includes(legal)) NICKNAME_REVERSE[nick].push(legal);
  }
}

const STRIP_SUFFIXES = new Set(["JR","SR","II","III","IV","EST","TR","TRUSTEE","ETAL","ET","AL","THE","AND","OF","MR","MRS","MS","DR"]);

function normName(s) {
  return (s||"").toUpperCase().replace(/[^A-Z\s]/g," ").replace(/\s+/g," ").trim();
}
function tokenize(s) {
  return normName(s).split(" ").filter(t => t.length > 0 && !STRIP_SUFFIXES.has(t));
}

// Parse SDAT owner string into { first, last }
// SDAT format is typically "LASTNAME FIRSTNAME" or "LASTNAME FIRSTNAME MIDDLE"
function parseSDATName(sdatOwner) {
  const tokens = tokenize(sdatOwner);
  if (tokens.length === 0) return { first:"", last:"" };
  if (tokens.length === 1) return { first:"", last:tokens[0] };
  // First token is last name in SDAT format
  return { last: tokens[0], first: tokens.slice(1).join(" ") };
}

// Classify match given separate first + last from CSV against a SDAT owner string.
// SDAT stores names as "LASTNAME FIRSTNAME [MIDDLE]" so we must handle that format.
// We also strip suffixes from the decedent last name before comparing (handles "KROL SR").
function classifyMatch(decFirst, decLast, sdatOwner) {
  const dFirst   = normName(decFirst);
  const dLastRaw = normName(decLast);
  // Strip any suffixes that leaked into the last name field (e.g. "KROL SR" -> "KROL")
  const dLastTokens = dLastRaw.split(" ").filter(t => t && !STRIP_SUFFIXES.has(t));
  const dLast = dLastTokens.join(" ");

  const sNorm   = normName(sdatOwner);
  const sTokens = tokenize(sdatOwner);

  if (!dLast) return { status:"none", reason:"No last name provided" };
  if (!sNorm)  return { status:"none", reason:"Empty SDAT owner" };

  // --- Last name check ---
  // Use a word-boundary-aware check: the last name must appear as a distinct token
  // in the SDAT string, not just as a substring (avoids DAVIS matching DAVIDSON)
  const lastNameFound = sTokens.includes(dLast) ||
    // Also allow substring for hyphenated/compound names longer than 4 chars
    (dLast.length > 4 && sNorm.includes(dLast));

  if (!lastNameFound) {
    return { status:"none", reason:`Last name "${dLast}" not in SDAT "${sdatOwner}"` };
  }

  if (!dFirst) {
    return { status:"none", reason:"Last name found but no first name to verify" };
  }

  // --- First name check ---
  // SDAT format: first token = last name, remaining tokens = first + middle
  // So we check if dFirst appears anywhere after the first token in SDAT
  const sFirstTokens = sTokens.slice(1); // everything after SDAT last name
  const sFirstNorm   = sFirstTokens.join(" ");

  // CONFIRMED: exact first name match (not a bare initial)
  if (dFirst.length > 1 && (sFirstTokens.includes(dFirst) || sFirstNorm.includes(dFirst))) {
    return { status:"confirmed", reason:`"${dLast}" + "${dFirst}" both matched` };
  }

  // POSSIBLE: SDAT has only an initial where we have a full first name
  if (dFirst.length > 1 && sFirstTokens.includes(dFirst[0]) && sFirstTokens.some(t => t.length === 1)) {
    return { status:"possible", reason:`Last name matched; SDAT has initial "${dFirst[0]}" only` };
  }

  // POSSIBLE: nickname match (decedent has legal name, SDAT has nickname or vice versa)
  if (dFirst.length > 1) {
    for (const nick of (NICKNAMES[dFirst] || [])) {
      if (sFirstTokens.includes(nick) || sFirstNorm.includes(nick)) {
        return { status:"possible", reason:`Last name matched; nickname "${nick}" found (legal: "${dFirst}")` };
      }
    }
    for (const legal of (NICKNAME_REVERSE[dFirst] || [])) {
      if (sFirstTokens.includes(legal) || sFirstNorm.includes(legal)) {
        return { status:"possible", reason:`Last name matched; "${dFirst}" may be nickname for "${legal}" in SDAT` };
      }
    }
  }

  return { status:"none", reason:`Last name "${dLast}" found but no first name or nickname match in SDAT "${sdatOwner}"` };
}

// Strip suffixes from a raw last name field before searching
// e.g. "KROL SR" -> "KROL", "SMITH JR" -> "SMITH"
function cleanLastName(raw) {
  const tokens = normName(raw).split(" ").filter(t => t.length > 0);
  // Remove any trailing suffix tokens
  while (tokens.length > 1 && STRIP_SUFFIXES.has(tokens[tokens.length - 1])) {
    tokens.pop();
  }
  return tokens.join(" ");
}

// SDAT lookup by last name statewide
async function lookupByLastName(lastName) {
  const ln = cleanLastName(lastName); // strips "SR", "JR", etc. from last name field
  if (ln.length < 2) return { records:null, error:"Last name too short" };
  const where = `upper(ownname1) like '%${ln}%' OR upper(ownname2) like '%${ln}%'`;
  const url = ENDPOINT + "?$limit=20&$where=" + encodeURIComponent(where);
  try {
    const r = await fetch(url);
    if (!r.ok) return { records:null, error:"API error " + r.status };
    const d = await r.json();
    return { records: d.length ? d : null, error:null };
  } catch(e) {
    return { records:null, error:e.message };
  }
}

// ---------------------------------------------------------------------------
// CSV parser
// ---------------------------------------------------------------------------
function parseCSV(text) {
  const lines = text.trim().split(/\r?\n/);
  if (lines.length < 2) return { headers:[], rows:[] };
  function splitRow(line) {
    const out=[]; let cur="",q=false;
    for (let i=0;i<line.length;i++) {
      const ch=line[i];
      if (ch==='"'){if(q&&line[i+1]==='"'){cur+='"';i++;}else{q=!q;}continue;}
      if (ch===','&&!q){out.push(cur.trim());cur="";continue;}
      cur+=ch;
    }
    out.push(cur.trim()); return out;
  }
  const headers=splitRow(lines[0]);
  const rows=lines.slice(1).filter(l=>l.trim()).map(l=>{
    const v=splitRow(l);
    return Object.fromEntries(headers.map((h,i)=>[h,v[i]!==undefined?v[i]:""]));
  });
  return {headers,rows};
}

function findCol(headers, ...words) {
  const h = headers.map(x=>x.toLowerCase());
  const idx = h.findIndex(c => words.some(w => c.includes(w)));
  return idx >= 0 ? headers[idx] : "";
}

function populateSelect(id, headers, selected, addBlank) {
  const el=document.getElementById(id); el.innerHTML="";
  if (addBlank){const o=document.createElement("option");o.value="";o.textContent="‚Äî not used ‚Äî";el.appendChild(o);}
  headers.forEach(h=>{
    const o=document.createElement("option");o.value=h;o.textContent=h;
    if(h===selected) o.selected=true;
    el.appendChild(o);
  });
}

function buildPreview(headers, rows) {
  const cols = headers.slice(0, 8); // show first 8 columns
  const sample = rows.slice(0, 3);
  let html = '<table class="preview-table"><thead><tr>';
  cols.forEach(h => { html += `<th>${h}</th>`; });
  html += '</tr></thead><tbody>';
  sample.forEach(r => {
    html += '<tr>';
    cols.forEach(h => { html += `<td>${(r[h]||"").slice(0,30)}</td>`; });
    html += '</tr>';
  });
  html += '</tbody></table>';
  return html;
}

function loadFile(file) {
  if (!file || !file.name.endsWith(".csv")) return;
  const reader = new FileReader();
  reader.onload = e => {
    csvData = parseCSV(e.target.result);
    document.getElementById("fileName").textContent = "üìÑ " + file.name;
    document.getElementById("recordCount").textContent = csvData.rows.length.toLocaleString() + " records loaded";
    document.getElementById("dropEmpty").classList.add("hidden");
    document.getElementById("dropLoaded").classList.remove("hidden");

    const h = csvData.headers;

    // Auto-detect columns ‚Äî suggest only, user confirms
    const guessDecFirst = findCol(h, "decedent first","first name","firstname","dec first");
    const guessDecLast  = findCol(h, "decedent last","last name","lastname","dec last","surname");
    const guessAddr     = findCol(h, "decedent address","property address","address");
    const guessCounty   = findCol(h, "county","jurisdiction");

    populateSelect("colDecFirst", h, guessDecFirst, false);
    populateSelect("colDecLast",  h, guessDecLast,  false);
    populateSelect("colAddr",     h, guessAddr,     true);
    populateSelect("colCounty",   h, guessCounty,   true);

    document.getElementById("detectedInfo").innerHTML =
      `Auto-detected suggestions &nbsp;‚Üí&nbsp; ` +
      `<strong style="color:#e6edf3">Dec First:</strong> ${guessDecFirst||"?"} &nbsp;|&nbsp; ` +
      `<strong style="color:#e6edf3">Dec Last:</strong> ${guessDecLast||"?"} &nbsp;|&nbsp; ` +
      `<strong style="color:#e6edf3">Address:</strong> ${guessAddr||"‚Äî"} &nbsp;|&nbsp; ` +
      `<strong style="color:#e6edf3">County:</strong> ${guessCounty||"‚Äî"}<br/>` +
      `<span style="color:#6e7681">Verify each column below before running.</span>`;

    document.getElementById("previewWrap").innerHTML = buildPreview(csvData.headers, csvData.rows);

    document.getElementById("mappingCard").classList.remove("hidden");
    document.getElementById("runCard").classList.remove("hidden");
    document.getElementById("resultsCard").classList.add("hidden");
    document.getElementById("logBox").innerHTML = "";
    document.getElementById("logBox").classList.add("hidden");

    // Reset results
    confirmedRows=[]; possibleRows=[]; noMatchRows=[];
  };
  reader.readAsText(file);
}

const dz=document.getElementById("dropzone");
dz.addEventListener("click",()=>document.getElementById("fileInput").click());
dz.addEventListener("dragover",e=>{e.preventDefault();dz.classList.add("active");});
dz.addEventListener("dragleave",()=>dz.classList.remove("active"));
dz.addEventListener("drop",e=>{e.preventDefault();dz.classList.remove("active");loadFile(e.dataTransfer.files[0]);});
document.getElementById("fileInput").addEventListener("change",e=>loadFile(e.target.files[0]));

function addLog(msg) {
  const box=document.getElementById("logBox");
  box.classList.remove("hidden");
  const line=document.createElement("div");line.textContent=msg;
  box.appendChild(line);
  if(box.children.length>400) box.removeChild(box.firstChild);
  box.scrollTop=box.scrollHeight;
}

// ---------------------------------------------------------------------------
// Run ‚Äî only fires on explicit button click, never automatically
// ---------------------------------------------------------------------------
document.getElementById("btnRun").addEventListener("click", async () => {
  if (!csvData) return;

  const decFirstCol = document.getElementById("colDecFirst").value;
  const decLastCol  = document.getElementById("colDecLast").value;
  const addrCol     = document.getElementById("colAddr").value;
  const countyCol   = document.getElementById("colCounty").value;

  if (!decFirstCol || !decLastCol) {
    alert("Please select both First Name and Last Name columns before running.");
    return;
  }

  aborted=false; confirmedRows=[]; possibleRows=[]; noMatchRows=[];

  const btnRun=document.getElementById("btnRun");
  btnRun.disabled=true; btnRun.textContent="Running‚Ä¶";
  document.getElementById("btnStop").classList.remove("hidden");
  document.getElementById("progWrap").classList.remove("hidden");
  document.getElementById("progText").classList.remove("hidden");
  document.getElementById("logBox").innerHTML="";
  document.getElementById("logBox").classList.remove("hidden");
  document.getElementById("resultsCard").classList.add("hidden");

  const total=csvData.rows.length;

  for (let i=0;i<total;i++) {
    if (aborted){addLog("‚ö† Stopped at row "+(i+1));break;}

    const row      = csvData.rows[i];
    const decFirst = (row[decFirstCol]||"").trim();
    const decLast  = (row[decLastCol] ||"").trim();

    let matchStatus="none", matchReason="", sdatFirst="", sdatLast="", sdatAddr="";

    if (!decLast) {
      matchReason="No last name";
    } else {
      // cleanLastName strips suffixes like SR/JR from the last name field before searching
      const {records,error} = await lookupByLastName(decLast);

      if (error && !records) {
        matchReason="Lookup error: "+error;
        addLog(`Row ${i+1}: ${decFirst} ${decLast} ‚Äî ${matchReason}`);
      } else if (records) {
        let bestStatus="none", bestReason="", bestFirst="", bestLast="", bestAddr="";

        for (const rec of records) {
          const o1=(rec.ownname1||"").trim();
          const o2=(rec.ownname2||"").trim();
          for (const candidate of [o1,o2].filter(Boolean)) {
            const {status,reason}=classifyMatch(decFirst, decLast, candidate);
            if (status==="confirmed") {
              const parsed=parseSDATName(candidate);
              bestStatus="confirmed"; bestReason=reason;
              bestFirst=parsed.first; bestLast=parsed.last;
              bestAddr=[rec.premsnum,rec.premsnam,rec.premcity,rec.premzip].filter(Boolean).join(" ");
              break;
            } else if (status==="possible" && bestStatus!=="confirmed") {
              const parsed=parseSDATName(candidate);
              bestStatus="possible"; bestReason=reason;
              bestFirst=parsed.first; bestLast=parsed.last;
              bestAddr=[rec.premsnum,rec.premsnam,rec.premcity,rec.premzip].filter(Boolean).join(" ");
            }
          }
          if (bestStatus==="confirmed") break;
        }

        matchStatus=bestStatus;
        matchReason=bestReason||`${records.length} record(s) found, no name match`;
        sdatFirst=bestFirst; sdatLast=bestLast; sdatAddr=bestAddr;

        if (matchStatus==="none") {
          const sample=records.slice(0,2).map(r=>r.ownname1||"?").join(", ");
          addLog(`Row ${i+1}: ‚ùå ${decFirst} ${decLast} ‚Äî no match (SDAT: ${sample})`);
        } else if (matchStatus==="possible") {
          addLog(`Row ${i+1}: ‚ö†Ô∏è ${decFirst} ${decLast} ‚Äî possible (${matchReason})`);
        }
      } else {
        matchReason="No SDAT records for last name "+decLast;
        addLog(`Row ${i+1}: ‚ùå ${decFirst} ${decLast} ‚Äî ${matchReason}`);
      }
    }

    const outRow=Object.assign({},row);
    outRow["_Match_Status"] = matchStatus==="confirmed"?"‚úÖ CONFIRMED":matchStatus==="possible"?"‚ö†Ô∏è POSSIBLE":"‚ùå NO MATCH";
    outRow["_Match_Reason"] = matchReason;
    outRow["_SDAT_First"]   = sdatFirst;
    outRow["_SDAT_Last"]    = sdatLast;
    outRow["_SDAT_Address"] = sdatAddr;

    if (matchStatus==="confirmed")     confirmedRows.push(outRow);
    else if (matchStatus==="possible") possibleRows.push(outRow);
    else                               noMatchRows.push(outRow);

    const pct=Math.round(((i+1)/total)*100);
    document.getElementById("progFill").style.width=pct+"%";
    document.getElementById("progText").innerHTML=
      `${pct}% &nbsp;¬∑&nbsp; `+
      `<span style="color:#3fb950">${confirmedRows.length} confirmed</span> &nbsp;¬∑&nbsp; `+
      `<span style="color:#e3b341">${possibleRows.length} possible</span> &nbsp;¬∑&nbsp; `+
      `<span style="color:#f0883e">${noMatchRows.length} no match</span>`;

    await new Promise(r=>setTimeout(r,120));
  }

  document.getElementById("statTotal").textContent    =total.toLocaleString();
  document.getElementById("statConfirmed").textContent=confirmedRows.length.toLocaleString();
  document.getElementById("statPossible").textContent =possibleRows.length.toLocaleString();
  document.getElementById("statNone").textContent     =noMatchRows.length.toLocaleString();
  document.getElementById("statRate").textContent     =total?Math.round(((confirmedRows.length+possibleRows.length)/total)*100)+"%":"0%";

  btnRun.disabled=false; btnRun.textContent="‚ñ∂  Run Verification";
  document.getElementById("btnStop").classList.add("hidden");
  document.getElementById("resultsCard").classList.remove("hidden");
});

document.getElementById("btnStop").addEventListener("click",()=>{aborted=true;});

// ---------------------------------------------------------------------------
// Download 3-tab XLSX ‚Äî separate first/last name columns throughout
// ---------------------------------------------------------------------------
document.getElementById("btnDownload").addEventListener("click",()=>{
  const origHeaders=csvData.headers;
  const extraCols=["_Match_Status","_Match_Reason","_SDAT_First","_SDAT_Last","_SDAT_Address"];
  const outHeaders=[...origHeaders,...extraCols];

  function toSheet(rows){
    return XLSX.utils.aoa_to_sheet([outHeaders,...rows.map(r=>outHeaders.map(h=>r[h]||""))]);
  }
  function styleHeader(ws,n,bgHex,fgHex){
    for(let c=0;c<n;c++){
      const cell=XLSX.utils.encode_cell({r:0,c});
      if(!ws[cell])continue;
      ws[cell].s={font:{bold:true,color:{rgb:fgHex}},fill:{fgColor:{rgb:bgHex}},alignment:{horizontal:"center"}};
    }
  }

  const wb=XLSX.utils.book_new();
  const n=outHeaders.length;

  const ws1=toSheet(confirmedRows); styleHeader(ws1,n,"1a3d22","3fb950");
  XLSX.utils.book_append_sheet(wb,ws1,"Confirmed");

  const ws2=toSheet(possibleRows);  styleHeader(ws2,n,"2d2208","e3b341");
  XLSX.utils.book_append_sheet(wb,ws2,"Possible - Review");

  const ws3=toSheet(noMatchRows);   styleHeader(ws3,n,"2d0f0e","f0883e");
  XLSX.utils.book_append_sheet(wb,ws3,"No Match");

  XLSX.writeFile(wb,`homeowner_verification_${new Date().toISOString().slice(0,10)}.xlsx`);
});
</script>
</body>
</html>
