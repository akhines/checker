<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>MD Homeowner Verification</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  body { background: #0d1117; color: #e6edf3; font-family: Georgia, serif; min-height: 100vh; padding: 2rem 1rem; }
  .wrap { max-width: 720px; margin: 0 auto; }
  .eyebrow { display: flex; align-items: center; gap: 8px; font-family: monospace; font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.12em; color: #3fb950; margin-bottom: 0.5rem; }
  .dot { width: 8px; height: 8px; border-radius: 50%; background: #238636; flex-shrink: 0; }
  h1 { font-size: 1.9rem; font-weight: 700; color: #fff; margin-bottom: 0.25rem; }
  .subtitle { color: #8b949e; font-size: 0.9rem; font-style: italic; margin-bottom: 2rem; }
  .card { background: #161b22; border: 1px solid #30363d; border-radius: 8px; padding: 1.5rem; margin-bottom: 1.25rem; }
  .card-success { background: #161b22; border: 1px solid #238636; border-radius: 8px; padding: 1.5rem; margin-bottom: 1.25rem; }
  .card-title { font-family: monospace; font-size: 0.85rem; color: #58a6ff; border-bottom: 1px solid #21262d; padding-bottom: 0.6rem; margin-bottom: 1.25rem; }
  .card-title-green { font-family: monospace; font-size: 0.85rem; color: #3fb950; border-bottom: 1px solid #21262d; padding-bottom: 0.6rem; margin-bottom: 1.25rem; }
  .dropzone { border: 2px dashed #30363d; border-radius: 8px; padding: 2.5rem; text-align: center; cursor: pointer; transition: border-color 0.2s, background 0.2s; }
  .dropzone:hover, .dropzone.active { border-color: #58a6ff; background: rgba(88,166,255,0.04); }
  .badge { display: inline-block; background: #1a3d22; color: #3fb950; border-radius: 20px; padding: 0.2rem 0.75rem; font-family: monospace; font-size: 0.75rem; font-weight: 600; margin-top: 0.4rem; }
  .field { margin-bottom: 1rem; }
  .field label { display: block; font-family: monospace; font-size: 0.69rem; text-transform: uppercase; letter-spacing: 0.1em; color: #8b949e; margin-bottom: 0.3rem; }
  .field .hint { font-family: monospace; font-size: 0.71rem; color: #6e7681; margin-top: 0.2rem; }
  select { width: 100%; background: #0d1117; border: 1px solid #30363d; color: #e6edf3; border-radius: 4px; padding: 0.45rem 0.7rem; font-size: 0.85rem; font-family: monospace; outline: none; }
  select:focus { border-color: #58a6ff; }
  .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; }
  .grid3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1rem; }
  .btn-run  { background: #238636; color: #fff; border: none; border-radius: 6px; padding: 0.6rem 1.4rem; font-family: monospace; font-size: 0.85rem; font-weight: 700; cursor: pointer; transition: background 0.15s; }
  .btn-run:hover:not(:disabled) { background: #2ea043; }
  .btn-run:disabled { background: #1a3d22; color: #4d7a55; cursor: not-allowed; }
  .btn-debug { background: #6e40c9; color: #fff; border: none; border-radius: 6px; padding: 0.6rem 1.2rem; font-family: monospace; font-size: 0.85rem; font-weight: 700; cursor: pointer; }
  .btn-stop  { background: #da3633; color: #fff; border: none; border-radius: 6px; padding: 0.45rem 0.9rem; font-family: monospace; font-size: 0.78rem; cursor: pointer; }
  .btn-dl   { background: #1f6feb; color: #fff; border: none; border-radius: 6px; padding: 0.6rem 1.4rem; font-family: monospace; font-size: 0.85rem; font-weight: 700; cursor: pointer; }
  .btn-dl:hover { background: #388bfd; }
  .btn-row  { display: flex; align-items: center; gap: 0.75rem; flex-wrap: wrap; }
  .prog-wrap { margin-top: 0.75rem; background: #21262d; border-radius: 3px; height: 5px; overflow: hidden; }
  .prog-fill { height: 100%; background: linear-gradient(90deg,#238636,#2ea043); border-radius: 3px; transition: width 0.3s; }
  .prog-text { font-family: monospace; font-size: 0.78rem; color: #8b949e; }
  .log { background: #0d1117; border: 1px solid #21262d; border-radius: 4px; padding: 0.6rem 0.75rem; max-height: 150px; overflow-y: auto; font-family: monospace; font-size: 0.72rem; color: #8b949e; margin-top: 0.75rem; }
  .debug-panel { background: #0d1117; border: 1px solid #6e40c9; border-radius: 4px; padding: 0.75rem; font-family: monospace; font-size: 0.71rem; color: #c9d1d9; max-height: 500px; overflow-y: auto; white-space: pre-wrap; line-height: 1.6; margin-top: 1rem; }
  .stats { display: grid; grid-template-columns: repeat(5,1fr); gap: 0.6rem; margin-bottom: 1.25rem; }
  .stat-label { font-family: monospace; font-size: 0.6rem; text-transform: uppercase; letter-spacing: 0.06em; color: #8b949e; margin-bottom: 0.2rem; }
  .stat-value { font-size: 1.5rem; font-weight: 700; }
  .green  { color: #3fb950; } .yellow { color: #e3b341; } .orange { color: #f0883e; } .blue { color: #58a6ff; }
  .code-tag { background: #21262d; color: #8b949e; border-radius: 3px; padding: 0.1rem 0.4rem; font-family: monospace; font-size: 0.72rem; }
  .info-box { background: #1c2128; border: 1px solid #30363d; border-radius: 4px; padding: 0.65rem 0.85rem; font-family: monospace; font-size: 0.75rem; color: #8b949e; margin-bottom: 1rem; line-height: 1.6; }
  .legend-box { background: #1c2128; border: 1px solid #30363d; border-radius: 4px; padding: 0.65rem 0.85rem; font-family: monospace; font-size: 0.73rem; color: #8b949e; margin-bottom: 1rem; line-height: 2; }
  .tab-legend { display: flex; gap: 0.75rem; margin-bottom: 1rem; flex-wrap: wrap; }
  .tab-pill { display: inline-flex; align-items: center; gap: 0.4rem; background: #21262d; border-radius: 4px; padding: 0.3rem 0.7rem; font-family: monospace; font-size: 0.73rem; }
  .tab-pill .swatch { width: 10px; height: 10px; border-radius: 2px; flex-shrink: 0; }
  .section-label { font-family: monospace; font-size: 0.72rem; text-transform: uppercase; letter-spacing: 0.1em; color: #58a6ff; margin-bottom: 0.6rem; margin-top: 0.25rem; }
  .divider { border: none; border-top: 1px solid #21262d; margin: 1rem 0; }
  .preview-table { width: 100%; font-family: monospace; font-size: 0.7rem; border-collapse: collapse; margin-top: 0.5rem; }
  .preview-table th { background: #21262d; color: #8b949e; padding: 0.3rem 0.5rem; text-align: left; font-weight: normal; }
  .preview-table td { padding: 0.3rem 0.5rem; border-top: 1px solid #21262d; color: #58a6ff; }
  .footer { text-align: center; font-family: monospace; font-size: 0.7rem; color: #4d7a55; margin-top: 2rem; }
  .hidden { display: none; }
</style>
</head>
<body>
<div class="wrap">

  <div class="eyebrow"><span class="dot"></span>Maryland SDAT ¬∑ Public Records</div>
  <h1>Homeowner Verification</h1>
  <p class="subtitle">Address-based SDAT lookup ¬∑ Three-tier name match</p>

  <!-- Step 1 -->
  <div class="card">
    <div class="card-title">‚ë† Upload CSV</div>
    <div class="dropzone" id="dropzone">
      <input type="file" accept=".csv" id="fileInput" class="hidden"/>
      <div id="dropEmpty">
        <div style="font-size:2rem;margin-bottom:0.5rem">‚¨ÜÔ∏è</div>
        <div style="color:#8b949e;font-size:0.9rem">Drop your CSV here, or click to browse</div>
      </div>
      <div id="dropLoaded" class="hidden">
        <div style="font-family:monospace;margin-bottom:0.4rem" id="fileName"></div>
        <span class="badge" id="recordCount"></span>
      </div>
    </div>
  </div>

  <!-- Step 2 -->
  <div class="card hidden" id="mappingCard">
    <div class="card-title">‚ë° Map Columns</div>
    <div class="info-box" id="detectedInfo"></div>

    <div class="section-label">Decedent Name</div>
    <div class="grid2">
      <div class="field">
        <label>First Name Column *</label>
        <select id="colDecFirst"></select>
      </div>
      <div class="field">
        <label>Last Name Column *</label>
        <select id="colDecLast"></select>
      </div>
    </div>

    <hr class="divider"/>
    <div class="section-label">Property Address (used for SDAT lookup)</div>
    <div class="grid3">
      <div class="field">
        <label>Street Address *</label>
        <select id="colStreet"></select>
        <div class="hint">e.g. "11 BEAVER POND CIR"</div>
      </div>
      <div class="field">
        <label>ZIP Code *</label>
        <select id="colZip"></select>
        <div class="hint">5-digit zip</div>
      </div>
      <div class="field">
        <label>Property County *</label>
        <select id="colCounty"></select>
        <div class="hint">Used to build SDAT query</div>
      </div>
    </div>

    <hr class="divider"/>
    <div class="section-label">Preview ‚Äî first 3 rows</div>
    <div id="previewWrap" style="overflow-x:auto;"></div>
  </div>

  <!-- Step 3 -->
  <div class="card hidden" id="runCard">
    <div class="card-title">‚ë¢ Verify Against SDAT</div>
    <div class="legend-box">
      <span style="color:#3fb950">‚úÖ CONFIRMED</span> ‚Äî Address found in SDAT, first &amp; last name both match owner<br/>
      <span style="color:#e3b341">‚ö†Ô∏è POSSIBLE</span> ‚Äî Address found, last name matches, first is nickname or initial<br/>
      <span style="color:#f0883e">‚ùå NO MATCH</span> ‚Äî Address not found in SDAT, or owner name does not match
    </div>
    <div class="btn-row">
      <button class="btn-run"   id="btnRun">‚ñ∂&nbsp; Run Verification</button>
      <button class="btn-debug" id="btnDebug">üîç&nbsp; Debug First 5</button>
      <button class="btn-stop hidden" id="btnStop">‚ñ†&nbsp; Stop</button>
      <span class="prog-text hidden" id="progText"></span>
    </div>
    <div class="prog-wrap hidden" id="progWrap">
      <div class="prog-fill" id="progFill" style="width:0%"></div>
    </div>
    <div id="debugPanel" class="debug-panel hidden"></div>
    <div class="log hidden" id="logBox"></div>
  </div>

  <!-- Results -->
  <div class="card-success hidden" id="resultsCard">
    <div class="card-title-green">‚úì Verification Complete</div>
    <div class="stats">
      <div><div class="stat-label">Checked</div>  <div class="stat-value blue"   id="statTotal">0</div></div>
      <div><div class="stat-label">Confirmed</div><div class="stat-value green"  id="statConfirmed">0</div></div>
      <div><div class="stat-label">Possible</div> <div class="stat-value yellow" id="statPossible">0</div></div>
      <div><div class="stat-label">No Match</div> <div class="stat-value orange" id="statNone">0</div></div>
      <div><div class="stat-label">Hit Rate</div> <div class="stat-value"        id="statRate">0%</div></div>
    </div>
    <div class="tab-legend">
      <div class="tab-pill"><span class="swatch" style="background:#238636"></span>Tab 1: Confirmed</div>
      <div class="tab-pill"><span class="swatch" style="background:#b3891b"></span>Tab 2: Possible ‚Äî Review</div>
      <div class="tab-pill"><span class="swatch" style="background:#b03a2e"></span>Tab 3: No Match</div>
    </div>
    <button class="btn-dl" id="btnDownload">‚¨á&nbsp; Download Excel (.xlsx)</button>
    <div style="margin-top:0.75rem;font-family:monospace;font-size:0.72rem;color:#6e7681">
      All tabs include original columns +
      <span class="code-tag">_Match_Status</span>
      <span class="code-tag">_Match_Reason</span>
      <span class="code-tag">_SDAT_Owner_First</span>
      <span class="code-tag">_SDAT_Owner_Last</span>
      <span class="code-tag">_SDAT_Address</span>
    </div>
  </div>

  <div class="footer">Maryland Open Data ¬∑ SDAT Real Property (x8a5-h2sy) ¬∑ Lookup by property address</div>
</div>

<script>
const ENDPOINT = "https://opendata.maryland.gov/resource/x8a5-h2sy.json";
let csvData = null;
let confirmedRows = [], possibleRows = [], noMatchRows = [];
let aborted = false;

// ---------------------------------------------------------------------------
// Maryland county codes for SDAT
// ---------------------------------------------------------------------------
const COUNTY_CODES = {
  "ALLEGANY":       "ALLE",
  "ANNE ARUNDEL":   "ANNE",
  "BALTIMORE CITY": "BACI",
  "BALTIMORE":      "BALT",
  "CALVERT":        "CALV",
  "CAROLINE":       "CARO",
  "CARROLL":        "CARR",
  "CECIL":          "CECI",
  "CHARLES":        "CHAR",
  "DORCHESTER":     "DORC",
  "FREDERICK":      "FRED",
  "GARRETT":        "GARR",
  "HARFORD":        "HARF",
  "HOWARD":         "HOWA",
  "KENT":           "KENT",
  "MONTGOMERY":     "MONT",
  "PRINCE GEORGE'S":"PRIN",
  "PRINCE GEORGES": "PRIN",
  "QUEEN ANNE'S":   "QUEE",
  "QUEEN ANNES":    "QUEE",
  "SAINT MARY'S":   "SAIN",
  "SAINT MARYS":    "SAIN",
  "ST MARY'S":      "SAIN",
  "ST MARYS":       "SAIN",
  "SOMERSET":       "SOME",
  "TALBOT":         "TALB",
  "WASHINGTON":     "WASH",
  "WICOMICO":       "WICO",
  "WORCESTER":      "WORC",
};

function getCountyCode(raw) {
  if (!raw) return null;
  const up = raw.toUpperCase().trim();
  // Direct lookup
  if (COUNTY_CODES[up]) return COUNTY_CODES[up];
  // Partial match
  for (const [name, code] of Object.entries(COUNTY_CODES)) {
    if (up.includes(name) || name.includes(up)) return code;
  }
  // Already a 4-letter code
  if (up.length === 4) return up;
  return null;
}

// ---------------------------------------------------------------------------
// Address parsing ‚Äî split "11 BEAVER POND CIR" into number + street name
// ---------------------------------------------------------------------------
function parseStreet(raw) {
  const s = (raw || "").trim().toUpperCase();
  const m = s.match(/^(\d+\S*)\s+(.+)$/);
  if (m) return { num: m[1], street: m[2].trim() };
  return { num: "", street: s };
}

function normalizeStreetName(s) {
  return s.toUpperCase()
    .replace(/\bSTREET\b/g,"ST").replace(/\bAVENUE\b/g,"AVE").replace(/\bROAD\b/g,"RD")
    .replace(/\bDRIVE\b/g,"DR").replace(/\bCOURT\b/g,"CT").replace(/\bLANE\b/g,"LN")
    .replace(/\bBOULEVARD\b/g,"BLVD").replace(/\bCIRCLE\b/g,"CIR").replace(/\bPLACE\b/g,"PL")
    .replace(/\bHIGHWAY\b/g,"HWY").replace(/\bPARKWAY\b/g,"PKWY").replace(/\bTERRACE\b/g,"TER")
    .replace(/\bTRAIL\b/g,"TRL").replace(/\bSQUARE\b/g,"SQ").replace(/\bNORTH\b/g,"N")
    .replace(/\bSOUTH\b/g,"S").replace(/\bEAST\b/g,"E").replace(/\bWEST\b/g,"W")
    .replace(/\s+/g," ").trim();
}

// ---------------------------------------------------------------------------
// SDAT address-based lookup
// ---------------------------------------------------------------------------
async function lookupByAddress(streetRaw, zipRaw, countyRaw, debug) {
  const countyCode = getCountyCode(countyRaw);
  if (!countyCode) {
    if (debug) debug("  ‚ö† Could not resolve county code for: " + countyRaw);
    return { records: null, error: "Unknown county: " + countyRaw };
  }

  const { num, street } = parseStreet(streetRaw);
  const streetNorm = normalizeStreetName(street);
  const zip = (zipRaw || "").trim().replace(/-\d{4}$/, "").trim();

  // Build query ‚Äî search by street name + zip in the correct county
  // premsnam = street name, premsnum = street number, premzip = zip, county code filters to right jurisdiction
  let where = "upper(premsnam) like '%" + streetNorm + "%'";
  if (num)  where += " AND premsnum='" + num + "'";
  if (zip)  where += " AND premzip like '" + zip + "%'";
  if (countyCode) where += " AND county='" + countyCode + "'";

  const url = ENDPOINT + "?$limit=10&$where=" + encodeURIComponent(where);

  if (debug) {
    debug("  County: " + countyRaw + " ‚Üí code: " + countyCode);
    debug("  Street parsed: num=\"" + num + "\"  name=\"" + streetNorm + "\"  zip=\"" + zip + "\"");
    debug("  URL: " + url);
  }

  try {
    const r = await fetch(url);
    if (!r.ok) return { records: null, error: "API error " + r.status };
    const d = await r.json();
    return { records: d.length ? d : null, error: null };
  } catch(e) {
    return { records: null, error: e.message };
  }
}

// ---------------------------------------------------------------------------
// Name matching
// ---------------------------------------------------------------------------
const STRIP_SUFFIXES = new Set(["JR","SR","II","III","IV","EST","TR","TRUSTEE","ETAL","ET","AL","THE","AND","OF","MR","MRS","MS","DR"]);

const NICKNAMES = {
  WILLIAM:["BILL","BILLY","WILL","WILLY","LIAM"],ROBERT:["BOB","BOBBY","ROB","ROBBIE"],
  JAMES:["JIM","JIMMY","JAMIE","JAY"],JOHN:["JACK","JOHNNY","JON"],
  MICHAEL:["MIKE","MIKEY","MICK","MICKEY"],RICHARD:["RICK","RICKY","DICK","RICH"],
  CHARLES:["CHUCK","CHARLIE","CHAS"],THOMAS:["TOM","TOMMY","THOM"],
  JOSEPH:["JOE","JOEY"],DAVID:["DAVE","DAVY"],EDWARD:["ED","EDDIE","NED","TED","TEDDY"],
  HENRY:["HANK","HAL"],HAROLD:["HAL","HARRY"],DONALD:["DON","DONNIE"],RONALD:["RON","RONNIE"],
  KENNETH:["KEN","KENNY"],STEVEN:["STEVE","STEVIE"],STEPHEN:["STEVE","STEVIE"],
  DANIEL:["DAN","DANNY"],ANTHONY:["TONY"],ANDREW:["ANDY","DREW"],
  FRANK:["FRANCIS","FRANKIE"],FRANCIS:["FRANK","FRAN"],PATRICK:["PAT","PATTY"],
  TIMOTHY:["TIM","TIMMY"],RAYMOND:["RAY"],LAWRENCE:["LARRY"],LARRY:["LAWRENCE"],
  WALTER:["WALT","WALLY"],PETER:["PETE"],EUGENE:["GENE"],ARTHUR:["ART","ARTIE"],
  ALBERT:["AL","BERT"],SAMUEL:["SAM","SAMMY"],FREDERICK:["FRED","FREDDY"],FRED:["FREDERICK","FREDDY"],
  GERALD:["JERRY","GERRY"],JERRY:["GERALD","GERRY"],LEONARD:["LEN","LENNY","LEO"],
  LOUIS:["LOU","LOUIE","LEWIS"],LEWIS:["LOU","LOUIE","LOUIS"],NATHANIEL:["NAT","NATE"],
  NICHOLAS:["NICK","NICKY"],NORMAN:["NORM"],RANDOLPH:["RANDY"],RANDY:["RANDOLPH"],
  RODNEY:["ROD"],RUSSELL:["RUSS"],STANLEY:["STAN"],THEODORE:["TED","TEDDY","THEO"],
  VICTOR:["VIC"],VINCENT:["VIN","VINCE","VINNY"],GEORGE:["GEORGIE"],HOWARD:["HOWIE"],
  DOUGLAS:["DOUG"],DENNIS:["DENNY"],CLIFFORD:["CLIFF"],JEROME:["JERRY"],ERNEST:["ERNIE"],
  ELIZABETH:["LIZ","LIZZIE","BETH","BETTY","BETTE","ELIZA","ELLIE","LIBBY","LISA","ELISE","ELSIE"],
  BETTY:["ELIZABETH","BETTE"],MARGARET:["MAGGIE","MEG","PEGGY","PEG","MARGE","MARGO","RITA"],
  MARY:["MARIE","MOLLY","MAE","MAY","MAMIE","POLLY"],
  PATRICIA:["PAT","PATTY","PATTI","TRICIA","TRISH"],BARBARA:["BARB","BARBIE","BABS"],
  DOROTHY:["DOT","DOTTIE"],HELEN:["NELL","NELLIE"],VIRGINIA:["GINNY","GINGER"],
  CATHERINE:["CATHY","KATHY","KATE","KATIE","KAY"],KATHERINE:["KATHY","KATE","KATIE","KAY","CATHY"],
  KATHLEEN:["KATHY","KATE","KATIE","KAY"],CAROLYN:["CAROL","CARRIE","LYNN"],
  CAROL:["CAROLE","CAROLYN","CARRIE"],JUDITH:["JUDY"],JUDY:["JUDITH"],PAMELA:["PAM"],
  SANDRA:["SANDY","SANDI"],SUSAN:["SUE","SUSIE","SUZY"],TERESA:["TERRY","TERI","TESS"],
  THERESA:["TERRY","TERI","TESS"],DEBORAH:["DEB","DEBBIE"],DEBRA:["DEB","DEBBIE"],
  CYNTHIA:["CINDY"],CONSTANCE:["CONNIE"],CONNIE:["CONSTANCE"],BEVERLY:["BEV"],
  FRANCES:["FRAN","FRANNIE"],LILLIAN:["LILY","LIL"],MILDRED:["MILLIE"],
  ROSEMARY:["ROSIE","ROSE"],EVELYN:["EVE","EVIE"],JOSEPHINE:["JO","JOSIE"],
  JOANNE:["JO","JOAN"],ROBERTA:["BOBBIE"],VIVIAN:["VIV"],DOLORES:["DEE","LOLA"],
  LAURA:["LAURIE","LORI"],LORI:["LAURA","LAURIE"],LORRAINE:["LORI"],GERALDINE:["GERI","JERRY"],
};

const NICKNAME_REVERSE = {};
for (const [legal, nicks] of Object.entries(NICKNAMES)) {
  for (const nick of nicks) {
    if (!NICKNAME_REVERSE[nick]) NICKNAME_REVERSE[nick] = [];
    if (!NICKNAME_REVERSE[nick].includes(legal)) NICKNAME_REVERSE[nick].push(legal);
  }
}

function normStr(s) {
  return (s||"").toUpperCase().replace(/[^A-Z\s]/g," ").replace(/\s+/g," ").trim();
}
function tokenize(s) {
  return normStr(s).split(" ").filter(t => t.length > 0 && !STRIP_SUFFIXES.has(t));
}
function stripSuffixesFromName(raw) {
  const t = normStr(raw).split(" ").filter(t => t.length > 0);
  while (t.length > 1 && STRIP_SUFFIXES.has(t[t.length-1])) t.pop();
  return t.join(" ");
}

// Compare decedent first+last against a SDAT owner string
// SDAT format: "LASTNAME FIRSTNAME [MIDDLE]"
function classifyMatch(decFirst, decLast, sdatOwner, debugFn) {
  const dFirst = normStr(decFirst);
  const dLast  = stripSuffixesFromName(normStr(decLast));
  const sTokens = tokenize(sdatOwner);
  const sNorm   = normStr(sdatOwner);

  if (!dLast) return { status:"none", reason:"No last name" };
  if (!sTokens.length) return { status:"none", reason:"Empty SDAT owner" };

  // Token-level last name check (avoids DAVIS matching DAVIDSON)
  const lastFound = sTokens.includes(dLast) || (dLast.length > 4 && sNorm.includes(dLast));
  if (!lastFound) return { status:"none", reason:"Last \""+dLast+"\" not in SDAT \""+sdatOwner+"\"" };
  if (!dFirst)   return { status:"none", reason:"Last name found but no first name to check" };

  // In SDAT format token[0] is the last name, everything after is first+middle
  const sAfterLast = sTokens.slice(sTokens.indexOf(dLast)+1);
  const sAfterNorm = sAfterLast.join(" ");

  if (debugFn) debugFn("    dFirst=\""+dFirst+"\" dLast=\""+dLast+"\" sAfterLast="+JSON.stringify(sAfterLast));

  // CONFIRMED: exact first name
  if (dFirst.length > 1 && (sAfterLast.includes(dFirst) || sAfterNorm.includes(dFirst))) {
    return { status:"confirmed", reason:"\""+dLast+"\" + \""+dFirst+"\" both matched" };
  }

  // POSSIBLE: initial only in SDAT
  if (dFirst.length > 1 && sAfterLast.some(t => t.length===1 && t===dFirst[0])) {
    return { status:"possible", reason:"Last matched; SDAT has initial \""+dFirst[0]+"\" only" };
  }

  // POSSIBLE: nickname
  if (dFirst.length > 1) {
    for (const nick of (NICKNAMES[dFirst]||[])) {
      if (sAfterLast.includes(nick)||sAfterNorm.includes(nick))
        return { status:"possible", reason:"Last matched; nickname \""+nick+"\" (legal: \""+dFirst+"\")" };
    }
    for (const legal of (NICKNAME_REVERSE[dFirst]||[])) {
      if (sAfterLast.includes(legal)||sAfterNorm.includes(legal))
        return { status:"possible", reason:"Last matched; \""+dFirst+"\" may be nickname for \""+legal+"\"" };
    }
  }

  return { status:"none", reason:"Last \""+dLast+"\" found but no first name match in \""+sdatOwner+"\"" };
}

// Parse SDAT owner name into separate first/last
function parseSDATOwner(sdatOwner) {
  const t = tokenize(sdatOwner);
  if (!t.length) return { first:"", last:"" };
  if (t.length===1) return { first:"", last:t[0] };
  return { last:t[0], first:t.slice(1).join(" ") };
}

// ---------------------------------------------------------------------------
// Run a single record through SDAT and return match result
// ---------------------------------------------------------------------------
async function processRecord(decFirst, decLast, streetRaw, zipRaw, countyRaw, debugFn) {
  const { records, error } = await lookupByAddress(streetRaw, zipRaw, countyRaw, debugFn);

  if (error && !records) return { status:"none", reason:"Lookup error: "+error, sdatFirst:"", sdatLast:"", sdatAddr:"" };

  if (!records) {
    // Address not found ‚Äî try relaxed search without street number
    const { num, street } = parseStreet(streetRaw);
    const streetNorm = normalizeStreetName(street);
    const zip = (zipRaw||"").trim().replace(/-\d{4}$/,"");
    const countyCode = getCountyCode(countyRaw);
    const where = "upper(premsnam) like '%"+streetNorm+"%' AND premzip like '"+zip+"%'"+(countyCode?" AND county='"+countyCode+"'":"");
    const url2 = ENDPOINT+"?$limit=10&$where="+encodeURIComponent(where);
    if (debugFn) debugFn("  Address not found ‚Äî retrying without street number\n  URL2: "+url2);
    try {
      const r2 = await fetch(url2);
      const d2 = await r2.json();
      if (!d2.length) return { status:"none", reason:"Address not found in SDAT", sdatFirst:"", sdatLast:"", sdatAddr:"" };
      if (debugFn) debugFn("  Retry returned "+d2.length+" record(s)");
      return matchFromRecords(d2, decFirst, decLast, debugFn);
    } catch(e) {
      return { status:"none", reason:"Retry error: "+e.message, sdatFirst:"", sdatLast:"", sdatAddr:"" };
    }
  }

  return matchFromRecords(records, decFirst, decLast, debugFn);
}

function matchFromRecords(records, decFirst, decLast, debugFn) {
  let best = { status:"none", reason:"", sdatFirst:"", sdatLast:"", sdatAddr:"" };

  for (const rec of records) {
    const o1 = (rec.ownname1||"").trim();
    const o2 = (rec.ownname2||"").trim();
    const addr = [rec.premsnum,rec.premsnam,rec.premcity,rec.premzip].filter(Boolean).join(" ");
    if (debugFn) debugFn("  ownname1=\""+o1+"\"  ownname2=\""+o2+"\"  addr=\""+addr+"\"");

    for (const candidate of [o1,o2].filter(Boolean)) {
      const r = classifyMatch(decFirst, decLast, candidate, debugFn);
      const icon = r.status==="confirmed"?"‚úÖ":r.status==="possible"?"‚ö†Ô∏è":"‚ùå";
      if (debugFn) debugFn("  "+icon+" vs \""+candidate+"\": "+r.status.toUpperCase()+" ‚Äî "+r.reason);

      if (r.status==="confirmed") {
        const p = parseSDATOwner(candidate);
        return { status:"confirmed", reason:r.reason, sdatFirst:p.first, sdatLast:p.last, sdatAddr:addr };
      }
      if (r.status==="possible" && best.status!=="confirmed") {
        const p = parseSDATOwner(candidate);
        best = { status:"possible", reason:r.reason, sdatFirst:p.first, sdatLast:p.last, sdatAddr:addr };
      }
    }
  }

  if (best.status==="none") {
    const sample = records.slice(0,3).map(r=>r.ownname1||"?").join(", ");
    best.reason = records.length+" record(s) found at address, name mismatch (SDAT: "+sample+")";
  }
  return best;
}

// ---------------------------------------------------------------------------
// CSV parser
// ---------------------------------------------------------------------------
function parseCSV(text) {
  const lines=text.trim().split(/\r?\n/);
  if (lines.length<2) return {headers:[],rows:[]};
  function splitRow(line) {
    const out=[];let cur="",q=false;
    for(let i=0;i<line.length;i++){
      const ch=line[i];
      if(ch==='"'){if(q&&line[i+1]==='"'){cur+='"';i++;}else{q=!q;}continue;}
      if(ch===','&&!q){out.push(cur.trim());cur="";continue;}
      cur+=ch;
    }
    out.push(cur.trim());return out;
  }
  const headers=splitRow(lines[0]);
  const rows=lines.slice(1).filter(l=>l.trim()).map(l=>{
    const v=splitRow(l);
    return Object.fromEntries(headers.map((h,i)=>[h,v[i]!==undefined?v[i]:""]));
  });
  return {headers,rows};
}

function findCol(headers,...words) {
  const h=headers.map(x=>x.toLowerCase());
  const idx=h.findIndex(c=>words.some(w=>c.includes(w)));
  return idx>=0?headers[idx]:"";
}

function populateSelect(id,headers,selected,addBlank) {
  const el=document.getElementById(id);el.innerHTML="";
  if(addBlank){const o=document.createElement("option");o.value="";o.textContent="‚Äî not used ‚Äî";el.appendChild(o);}
  headers.forEach(h=>{const o=document.createElement("option");o.value=h;o.textContent=h;if(h===selected)o.selected=true;el.appendChild(o);});
}

function buildPreview(headers,rows) {
  const cols=headers.slice(0,8);const sample=rows.slice(0,3);
  let html='<table class="preview-table"><thead><tr>';
  cols.forEach(h=>{html+=`<th>${h}</th>`;});
  html+='</tr></thead><tbody>';
  sample.forEach(r=>{html+='<tr>';cols.forEach(h=>{html+=`<td>${(r[h]||"").slice(0,28)}</td>`;});html+='</tr>';});
  html+='</tbody></table>';return html;
}

function loadFile(file) {
  if(!file||!file.name.endsWith(".csv")) return;
  const reader=new FileReader();
  reader.onload=e=>{
    csvData=parseCSV(e.target.result);
    document.getElementById("fileName").textContent="üìÑ "+file.name;
    document.getElementById("recordCount").textContent=csvData.rows.length.toLocaleString()+" records loaded";
    document.getElementById("dropEmpty").classList.add("hidden");
    document.getElementById("dropLoaded").classList.remove("hidden");

    const h=csvData.headers;
    const gFirst  = findCol(h,"decedent first","first name","firstname");
    const gLast   = findCol(h,"decedent last","last name","lastname","surname");
    const gStreet = findCol(h,"property address","street address","address");
    const gZip    = findCol(h,"property zip","zip code","zip","postal");
    const gCounty = findCol(h,"property county","county");

    populateSelect("colDecFirst",h,gFirst,false);
    populateSelect("colDecLast", h,gLast, false);
    populateSelect("colStreet",  h,gStreet,false);
    populateSelect("colZip",     h,gZip,  false);
    populateSelect("colCounty",  h,gCounty,false);

    document.getElementById("detectedInfo").innerHTML=
      `Auto-detected ‚Üí `+
      `<strong style="color:#e6edf3">First:</strong> ${gFirst||"?"} &nbsp;`+
      `<strong style="color:#e6edf3">Last:</strong> ${gLast||"?"} &nbsp;`+
      `<strong style="color:#e6edf3">Address:</strong> ${gStreet||"?"} &nbsp;`+
      `<strong style="color:#e6edf3">ZIP:</strong> ${gZip||"?"} &nbsp;`+
      `<strong style="color:#e6edf3">County:</strong> ${gCounty||"?"}<br/>`+
      `<span style="color:#6e7681">Verify each column before running.</span>`;

    document.getElementById("previewWrap").innerHTML=buildPreview(h,csvData.rows);
    document.getElementById("mappingCard").classList.remove("hidden");
    document.getElementById("runCard").classList.remove("hidden");
    document.getElementById("resultsCard").classList.add("hidden");
    document.getElementById("logBox").innerHTML="";
    document.getElementById("logBox").classList.add("hidden");
    document.getElementById("debugPanel").classList.add("hidden");
    confirmedRows=[]; possibleRows=[]; noMatchRows=[];
  };
  reader.readAsText(file);
}

const dz=document.getElementById("dropzone");
dz.addEventListener("click",()=>document.getElementById("fileInput").click());
dz.addEventListener("dragover",e=>{e.preventDefault();dz.classList.add("active");});
dz.addEventListener("dragleave",()=>dz.classList.remove("active"));
dz.addEventListener("drop",e=>{e.preventDefault();dz.classList.remove("active");loadFile(e.dataTransfer.files[0]);});
document.getElementById("fileInput").addEventListener("change",e=>loadFile(e.target.files[0]));

function addLog(msg) {
  const box=document.getElementById("logBox");
  box.classList.remove("hidden");
  const line=document.createElement("div");line.textContent=msg;
  box.appendChild(line);
  if(box.children.length>400) box.removeChild(box.firstChild);
  box.scrollTop=box.scrollHeight;
}

function getColValues() {
  return {
    decFirstCol: document.getElementById("colDecFirst").value,
    decLastCol:  document.getElementById("colDecLast").value,
    streetCol:   document.getElementById("colStreet").value,
    zipCol:      document.getElementById("colZip").value,
    countyCol:   document.getElementById("colCounty").value,
  };
}

// ---------------------------------------------------------------------------
// Run
// ---------------------------------------------------------------------------
document.getElementById("btnRun").addEventListener("click", async () => {
  if (!csvData) return;
  const { decFirstCol, decLastCol, streetCol, zipCol, countyCol } = getColValues();
  if (!decFirstCol||!decLastCol||!streetCol||!zipCol||!countyCol) {
    alert("Please map all required columns: First Name, Last Name, Street Address, ZIP, and County.");
    return;
  }

  aborted=false; confirmedRows=[]; possibleRows=[]; noMatchRows=[];
  const btnRun=document.getElementById("btnRun");
  btnRun.disabled=true; btnRun.textContent="Running‚Ä¶";
  document.getElementById("btnStop").classList.remove("hidden");
  document.getElementById("progWrap").classList.remove("hidden");
  document.getElementById("progText").classList.remove("hidden");
  document.getElementById("logBox").innerHTML="";
  document.getElementById("logBox").classList.remove("hidden");
  document.getElementById("debugPanel").classList.add("hidden");
  document.getElementById("resultsCard").classList.add("hidden");

  const total=csvData.rows.length;

  for (let i=0;i<total;i++) {
    if (aborted){addLog("‚ö† Stopped at row "+(i+1));break;}
    const row=csvData.rows[i];
    const decFirst=(row[decFirstCol]||"").trim();
    const decLast =(row[decLastCol] ||"").trim();
    const street  =(row[streetCol]  ||"").trim();
    const zip     =(row[zipCol]     ||"").trim();
    const county  =(row[countyCol]  ||"").trim();

    const result = await processRecord(decFirst, decLast, street, zip, county, null);

    if (result.status==="none") {
      addLog("Row "+(i+1)+": ‚ùå "+decFirst+" "+decLast+" @ "+street+" ‚Äî "+result.reason);
    } else if (result.status==="possible") {
      addLog("Row "+(i+1)+": ‚ö†Ô∏è "+decFirst+" "+decLast+" ‚Äî possible ("+result.reason+")");
    }

    const outRow=Object.assign({},row);
    outRow["_Match_Status"]    = result.status==="confirmed"?"‚úÖ CONFIRMED":result.status==="possible"?"‚ö†Ô∏è POSSIBLE":"‚ùå NO MATCH";
    outRow["_Match_Reason"]    = result.reason;
    outRow["_SDAT_Owner_First"]= result.sdatFirst;
    outRow["_SDAT_Owner_Last"] = result.sdatLast;
    outRow["_SDAT_Address"]    = result.sdatAddr;

    if (result.status==="confirmed")     confirmedRows.push(outRow);
    else if (result.status==="possible") possibleRows.push(outRow);
    else                                  noMatchRows.push(outRow);

    const pct=Math.round(((i+1)/total)*100);
    document.getElementById("progFill").style.width=pct+"%";
    document.getElementById("progText").innerHTML=
      pct+"% &nbsp;¬∑&nbsp; "+
      "<span style='color:#3fb950'>"+confirmedRows.length+" confirmed</span> &nbsp;¬∑&nbsp; "+
      "<span style='color:#e3b341'>"+possibleRows.length+" possible</span> &nbsp;¬∑&nbsp; "+
      "<span style='color:#f0883e'>"+noMatchRows.length+" no match</span>";

    await new Promise(r=>setTimeout(r,120));
  }

  document.getElementById("statTotal").textContent    =total.toLocaleString();
  document.getElementById("statConfirmed").textContent=confirmedRows.length.toLocaleString();
  document.getElementById("statPossible").textContent =possibleRows.length.toLocaleString();
  document.getElementById("statNone").textContent     =noMatchRows.length.toLocaleString();
  document.getElementById("statRate").textContent     =total?Math.round(((confirmedRows.length+possibleRows.length)/total)*100)+"%":"0%";
  btnRun.disabled=false; btnRun.textContent="‚ñ∂  Run Verification";
  document.getElementById("btnStop").classList.add("hidden");
  document.getElementById("resultsCard").classList.remove("hidden");
});

document.getElementById("btnStop").addEventListener("click",()=>{aborted=true;});

// ---------------------------------------------------------------------------
// Debug ‚Äî first 5 rows with full trace
// ---------------------------------------------------------------------------
document.getElementById("btnDebug").addEventListener("click", async () => {
  if (!csvData){alert("Load a CSV first.");return;}
  const { decFirstCol, decLastCol, streetCol, zipCol, countyCol } = getColValues();
  if (!decFirstCol||!decLastCol||!streetCol||!zipCol||!countyCol) {
    alert("Map all columns before debugging.");return;
  }

  const panel=document.getElementById("debugPanel");
  panel.classList.remove("hidden");
  panel.textContent="Debugging first 5 rows against SDAT...\n\n";

  const sample=csvData.rows.slice(0,5);
  for (let i=0;i<sample.length;i++) {
    const row=sample[i];
    const decFirst=(row[decFirstCol]||"").trim();
    const decLast =(row[decLastCol] ||"").trim();
    const street  =(row[streetCol]  ||"").trim();
    const zip     =(row[zipCol]     ||"").trim();
    const county  =(row[countyCol]  ||"").trim();

    panel.textContent+="‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n";
    panel.textContent+="ROW "+(i+1)+": "+decFirst+" "+decLast+"\n";
    panel.textContent+="Address: "+street+", "+zip+"  County: "+county+"\n";

    const dbg = msg => { panel.textContent+=msg+"\n"; panel.scrollTop=panel.scrollHeight; };

    const result = await processRecord(decFirst, decLast, street, zip, county, dbg);
    const icon = result.status==="confirmed"?"‚úÖ":result.status==="possible"?"‚ö†Ô∏è":"‚ùå";
    panel.textContent+="\n"+icon+" RESULT: "+result.status.toUpperCase()+" ‚Äî "+result.reason+"\n\n";

    await new Promise(r=>setTimeout(r,300));
  }
  panel.textContent+="‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nDone. Copy and paste output here.\n";
  panel.scrollTop=panel.scrollHeight;
});

// ---------------------------------------------------------------------------
// Download 3-tab XLSX
// ---------------------------------------------------------------------------
document.getElementById("btnDownload").addEventListener("click",()=>{
  const origHeaders=csvData.headers;
  const extraCols=["_Match_Status","_Match_Reason","_SDAT_Owner_First","_SDAT_Owner_Last","_SDAT_Address"];
  const outHeaders=[...origHeaders,...extraCols];

  function toSheet(rows){
    return XLSX.utils.aoa_to_sheet([outHeaders,...rows.map(r=>outHeaders.map(h=>r[h]||""))]);
  }
  function styleHeader(ws,n,bg,fg){
    for(let c=0;c<n;c++){
      const cell=XLSX.utils.encode_cell({r:0,c});
      if(!ws[cell])continue;
      ws[cell].s={font:{bold:true,color:{rgb:fg}},fill:{fgColor:{rgb:bg}},alignment:{horizontal:"center"}};
    }
  }

  const wb=XLSX.utils.book_new();const n=outHeaders.length;
  const ws1=toSheet(confirmedRows);styleHeader(ws1,n,"1a3d22","3fb950");
  XLSX.utils.book_append_sheet(wb,ws1,"Confirmed");
  const ws2=toSheet(possibleRows);styleHeader(ws2,n,"2d2208","e3b341");
  XLSX.utils.book_append_sheet(wb,ws2,"Possible - Review");
  const ws3=toSheet(noMatchRows);styleHeader(ws3,n,"2d0f0e","f0883e");
  XLSX.utils.book_append_sheet(wb,ws3,"No Match");
  XLSX.writeFile(wb,"homeowner_verification_"+new Date().toISOString().slice(0,10)+".xlsx");
});
</script>
</body>
</html>
